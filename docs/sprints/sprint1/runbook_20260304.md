# 2026.03.04 Runbook（AWS KMS 非対称鍵 / CloudTrail / IAM）

このドキュメントは [docs/sprints/sprint1/task.md](task.md) の **2026.03.04** に対応する「設定」手順書です。

対象タスク:
- 1.2.2 KMSの非対称鍵ペアを作成（用途: ENCRYPT_DECRYPT）
- 1.2.3 公開鍵取得（GetPublicKey）と kid（鍵識別子）運用を確定
- 1.2.4 CloudTrailを有効化（KMS操作の監査ログ）
- 1.2.5 IAMポリシーを作成
- 1.2.5.1 公開鍵取得（GetPublicKey）の許可主体を確定

---

## 前提

- AWS CLI が利用できること（または Console 手順でも可）
- 作業リージョンを決めていること（例: `ap-northeast-1`）
- KMS キーは「封筒暗号の KEK 相当（RSA 公開鍵で DEK をラップ / 私鍵でアンラップ）」として使う想定

以降で使うプレースホルダ:
- ※山括弧の `<...>` は「置き換え用の目印」です。Console の入力欄には `<` `>` を含めず、実値を入力してください。
- `<AWS_REGION>`: 例 `ap-northeast-1`
- `<KMS_KEY_ID>`: 例 `1234abcd-...`（KeyId）
- `<KMS_KEY_ARN>`: 例 `arn:aws:kms:...:key/1234...`
- `<KMS_ALIAS>`: 例 `alias/shadownav/kek-rsa-oaep`

---

## 1.2.2 KMS 非対称鍵ペアを作成（ENCRYPT_DECRYPT）

### 推奨パラメータ（まずはこれで固定）
- KeySpec: `RSA_2048`（Web側での RSA-OAEP ラップ用途を想定）
- KeyUsage: `ENCRYPT_DECRYPT`
- Tags:
  - `Project=shadowwork-navigator`
  - `Env=production`（または `staging`）
  - `Purpose=kek`

> 注: 署名用途（SIGN_VERIFY）ではなく暗号用途（ENCRYPT_DECRYPT）を選びます。

### Console（GUI）手順
1) AWS Console → KMS → Customer managed keys → Create key
2) Key type: Asymmetric
3) Key usage: Encrypt and decrypt
4) Key spec: RSA_2048
5) Alias を設定（例: `alias/shadownav/prod/kek-rsa-oaep`）
6) Key administrators / Key users を設定（後述の IAM 設計に従う）
7) 作成後、KeyId / KeyArn を控える

### AWS CLI 手順（例）

```bash
aws kms create-key --region <AWS_REGION> --key-usage ENCRYPT_DECRYPT --key-spec RSA_2048 --description "shadowwork-navigator KEK (RSA-OAEP)" --tags TagKey=Project,TagValue=shadowwork-navigator TagKey=Purpose,TagValue=kek
```

Alias 作成（`<KMS_KEY_ID>` を create-key の結果から取得）:

```bash
aws kms create-alias --region <AWS_REGION> --alias-name <KMS_ALIAS> --target-key-id <KMS_KEY_ID>
```

確認:

```bash
aws kms describe-key --region <AWS_REGION> --key-id <KMS_KEY_ID>
aws kms list-aliases --region <AWS_REGION> | findstr shadownav
```

---

## 1.2.3 GetPublicKey と kid 運用

### 公開鍵の取得（GetPublicKey）

```bash
aws kms get-public-key --region <AWS_REGION> --key-id <KMS_KEY_ID> --output json > kms-public-key.json
```

- `PublicKey` は base64 で返ります。
- 将来の API（例: `GET /api/crypto/kms_public_key`）で配布する形式は、後続タスク 4.3.* で最終決定します。

### kid（鍵識別子）をどうするか

このプロジェクトでは、まず以下のどちらかで運用を確定させるのが安全です。

#### 案A（推奨）: `kid = KMS KeyId`
- 例: `1234abcd-...`（UUID）
- 長所: 追加の計算が不要、確実に一意、運用が簡単
- 短所: キーローテーション時に kid が変わる（ただしそれで良い設計にする）

#### 案B: `kid = 公開鍵のサムプリント（JWK thumbprint等）`
- 長所: 公開鍵の内容に基づくため、配布キーの同一性が明確
- 短所: 変換・計算実装が必要（Web/Workers 両側の整合も必要）

まずは案Aで前に進め、必要になった時点（複数鍵併用・ローテーション設計の精緻化）で案Bへ移行可能です。

### kid の保存場所
- 運用メモとして `task.md`（完了欄）または別紙に `<KMS_KEY_ID>` と `<KMS_ALIAS>` を控える
- 実装では `KMS_KEY_ID` を Workers Vars/Secrets で参照する（後続タスク 1.5.1.7.4）

---

## 1.2.4 CloudTrail を有効化（KMS操作の監査ログ）

目的:
- `kms:Decrypt`（将来のアンラップ）など重要操作の監査証跡を残す

### 最小構成（推奨）
- 管理イベント（Management events）を記録（デフォルトで KMS を含む）
- S3 バケットへ保存
- 可能なら CloudWatch Logs にも転送（アラート/検索のため）

### Console 手順（概要）
1) CloudTrail → Trails → Create trail
2) Trail name: `shadowwork-navigator-trail`
3) Storage location（S3）を作成/選択
4) Log file SSE（暗号化）を有効化（SSE-S3 か SSE-KMS）
5) Management events: Read/Write を両方有効化
6) 作成後、Trail を有効化

### 監査できること（例）
- 誰が（どの IAM principal が）いつ `kms:Decrypt` / `kms:GetPublicKey` を呼んだか

---

## 1.2.5 IAM ポリシー作成 / 1.2.5.1 GetPublicKey の許可主体

### 設計方針
- 公開鍵の配布 API は「外部へ公開」されうるが、AWS 側の `kms:GetPublicKey` を叩けるのは **API実行主体のみ** に限定する
- `kms:Decrypt` はさらに強い制限（後続タスク 1.2.5.2 / 4.4.* で確定）

### GetPublicKey の許可主体（まずの結論）
- 許可主体: Cloudflare Workers が利用する AWS 資格情報（IAM User もしくは Role）
- それ以外（開発者個人・一般ユーザー・CIなど）は原則不可

### ポリシー雛形
- GetPublicKey のみ許可する最小ポリシー: [docs/sprints/sprint1/aws/iam/kms_get_public_key_policy.json](aws/iam/kms_get_public_key_policy.json)
- Decrypt を含むポリシーは後続タスクで追加（今は分離推奨）

### 次（03/06 の 1.5.1.7 へ繋ぐ）
- Workers 側に `AWS_REGION`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `KMS_KEY_ID` を登録する
- キーIDは alias ではなく KeyId/KeyArn を推奨（alias 変更による意図せぬ切替を防ぐ）

---

## 補足: Cloudflare Workers から AWS KMS を呼ぶための資格情報（段階的に安全化）

このプロジェクトでは「暗号化・復号を普段行うのは Cloudflare Workers 上の API」です。
一方で、Cloudflare Workers は AWS のサービス主体（例: Lambda）ではないため、**AWS 側で “実行主体(Principal)” として直接指定できません**。

そのため、まずは **IAM User（アクセスキー）** で運用を開始し、必要になったら **Role** に寄せていくのが現実的です。

### フェーズ1（最短で動かす）: IAM User（アクセスキー）で開始

#### 1) IAM User を作成（Console）
1) AWS Console → IAM → Users → Create user
2) User name: `shadownav-workers`
3) Access type:
	- **Console access: 付与しない**
	- Programmatic access（アクセスキー）を作成
4) Permissions:
	- 「ポリシーを直接アタッチ」でもよいが、まずは **最小権限のカスタムポリシー** を作る（次項）
5) Tags（任意）:
	- `Project=shadowwork-navigator`
	- `Purpose=workers-kms`

#### 2) 最小権限ポリシーを作成してアタッチ（GetPublicKey だけ）
1) まず KMS の `<KMS_KEY_ARN>` を確定する（KMS 画面の Key ARN）
2) [docs/sprints/sprint1/aws/iam/kms_get_public_key_policy.json](aws/iam/kms_get_public_key_policy.json) の `Resource` を `<KMS_KEY_ARN>` の実値に置換
3) AWS Console → IAM → Policies → Create policy → JSON に貼り付けて作成
  - Policy name 例: `shadownav-kms-get-public-key`
4) IAM → Users → `shadownav-workers` → Permissions → Add permissions で上記ポリシーをアタッチ

注意:
- 後続で `Decrypt`（アンラップ）を実装する場合は、**Decrypt は別ポリシーに分離**して追加する（いまは GetPublicKey だけに留める）

#### 3) Access Key を控える（重要）
- `AWS_ACCESS_KEY_ID` は後から確認できます
- `AWS_SECRET_ACCESS_KEY` は **作成直後にしか表示されません**（失った場合は新規作成して古いキーを無効化）

#### 4) Cloudflare Workers に Secrets を登録

`apps/api` 配下で実行:

```bash
cd apps/api
pnpm exec wrangler secret put AWS_ACCESS_KEY_ID --env staging
pnpm exec wrangler secret put AWS_SECRET_ACCESS_KEY --env staging

pnpm exec wrangler secret put AWS_ACCESS_KEY_ID --env production
pnpm exec wrangler secret put AWS_SECRET_ACCESS_KEY --env production
```

補足:
- `AWS_REGION` / `KMS_KEY_ID` は 03/06 のタスク（1.5.1.7.*）で Vars/Secrets に反映する

#### 5) 動作確認（AWS側）
ローカルで確認する場合（Access Key を一時的に環境変数へ入れて確認）:

```bash
aws sts get-caller-identity
aws kms get-public-key --region <AWS_REGION> --key-id <KMS_KEY_ID>
```

### フェーズ2（権限分離の改善）: IAM Role を導入して “実権限” を Role 側へ寄せる

このフェーズは「アクセスキーをゼロにする」ものではなく、**アクセスキー側の権限を最小化し、実権限を Role 側に集約**するための段階です。

前提:
- Cloudflare Workers が AWS にアクセスするための “入口” として IAM User（アクセスキー）は残ります
- その IAM User は **KMS 直接権限を持たず**、`sts:AssumeRole` だけを許可するように縮小します

#### 1) Role を作成（Console）
1) AWS Console → IAM → Roles → Create role
2) Trusted entity type:
	- AWS account（同一アカウント内の Principal を信頼）を選ぶ
3) Role name: `shadownav-workers-kms-role`
4) 作成後、Role ARN（例: `arn:aws:iam::<AWS_ACCOUNT_ID>:role/shadownav-workers-kms-role`）を控える

#### 2) 信頼ポリシー（Trust policy）を設定
この Role を使ってよいのは **IAM User `shadownav-workers` のみ**、という形にします。

Trust policy 例（`<AWS_ACCOUNT_ID>` は実値に置換）:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::<AWS_ACCOUNT_ID>:user/shadownav-workers"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```

Console では IAM → Roles → 対象 Role → Trust relationships → Edit で更新します。

#### 3) Role に KMS の実権限を付与
Role `shadownav-workers-kms-role` に、以下をアタッチします。

- GetPublicKey 用の最小権限ポリシー（本runbookのフェーズ1で作成した `shadownav-kms-get-public-key` 等）
- （将来）Decrypt 用のポリシー（別ポリシーとして追加）

#### 4) IAM User 側の権限を「AssumeRole のみ」に縮小
IAM User `shadownav-workers` に付与する権限は、最終的に以下だけにします。

- `sts:AssumeRole` を **特定の Role ARN のみに限定**

ポリシー例（`<ROLE_ARN>` を実値に置換）:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowAssumeWorkersKmsRoleOnly",
      "Effect": "Allow",
      "Action": "sts:AssumeRole",
      "Resource": "<ROLE_ARN>"
    }
  ]
}
```

この段階で、IAM User に付けていた KMS 直接権限（`kms:GetPublicKey` 等）は外します。

#### 5) Workers 実装側の対応（TODO）
Role を作っても、Workers が自動で Role を使うわけではありません。
API 実装側で STS `AssumeRole` を呼び、返ってきた一時クレデンシャルで KMS を呼ぶ実装が必要になります。

ポイント:
- Cloudflare Workers の実行時に STS を叩くため、API 実装が増えます（現状のスプリント計画では後段で対応するのが現実的）

### フェーズ3（理想形）: 長期アクセスキーを廃止（外部OIDC等）

GitHub Actions（OIDC）などは比較的定石がありますが、Cloudflare Workers 実行時に “キー無し” で AWS を呼ぶ設計は難易度が上がります。
この段階は、運用/監査要件が固まってから改めて設計します。
